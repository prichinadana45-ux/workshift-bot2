import os
import sqlite3
from datetime import datetime, timedelta
from aiogram import Bot, Dispatcher, types
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from openpyxl import Workbook
from io import BytesIO

# === –ù–ê–°–¢–†–û–ô–ö–ò ===
BOT_TOKEN = os.getenv("BOT_TOKEN") or "8355380571:AAEV9Yfraz1LEXFh5ZC3tq8Cv5LuN2KerYk"
ADMIN_IDS = [794753395]

POSITIONS = ["–û–ø–µ—Ä–∞—Ç–æ—Ä", "–£–ø–∞–∫–æ–≤—â–∏–∫"]
SECTIONS = ["3–¥", "–∫—Ä—É–≥–ª—ã–µ —Ñ–æ—Ä–º—ã", "—Ä—É—á–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏","–°–±–æ—Ä–∫–∞"]

# === –ë–ê–ó–ê –î–ê–ù–ù–´–• ===
def init_db():
    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    cur.execute('''
        CREATE TABLE IF NOT EXISTS jobs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            position TEXT NOT NULL,
            section TEXT NOT NULL,
            datetime TEXT NOT NULL,
            is_taken INTEGER DEFAULT 0,
            worker_id INTEGER,
            worker_name TEXT
        )
    ''')
    cur.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            full_name TEXT,
            position TEXT
        )
    ''')
    conn.commit()
    conn.close()

def get_user(user_id, full_name):
    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    cur.execute("SELECT position FROM users WHERE user_id = ?", (user_id,))
    row = cur.fetchone()
    if not row:
        # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        cur.execute("INSERT INTO users (user_id, full_name) VALUES (?, ?)", (user_id, full_name))
        conn.commit()
        position = None
    else:
        position = row[0]
    conn.close()
    return position

def save_user_position(user_id, position):
    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    cur.execute("UPDATE users SET position = ? WHERE user_id = ?", (position, user_id))
    conn.commit()
    conn.close()

def cleanup_old_jobs():
    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    now = datetime.now()
    cur.execute("SELECT id, datetime FROM jobs")
    rows = cur.fetchall()
    for row in rows:
        job_id, dt_str = row
        try:
            job_dt = datetime.strptime(dt_str, "%d.%m.%Y %H:%M")
            if job_dt < now - timedelta(hours=1):
                cur.execute("DELETE FROM jobs WHERE id = ?", (job_id,))
        except:
            pass
    conn.commit()
    conn.close()

# === –°–û–°–¢–û–Ø–ù–ò–Ø ===
class AddJob(StatesGroup):
    position = State()
    section = State()
    datetime = State()

class FindJob(StatesGroup):
    position = State()
    section = State()

class RegisterPosition(StatesGroup):
    position = State()

# === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher(bot, storage=MemoryStorage())

# === –ö–õ–ê–í–ò–ê–¢–£–†–´ ===
def get_positions_keyboard():
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    for pos in POSITIONS:
        keyboard.add(pos)
    return keyboard

def get_sections_keyboard():
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    for sec in SECTIONS:
        keyboard.add(sec)
    return keyboard

# === /start ‚Äî —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è ===
@dp.message_handler(commands=['start'])
async def start(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    full_name = message.from_user.full_name

    position = get_user(user_id, full_name)

    if user_id in ADMIN_IDS:
        await message.answer(
            f"üõ† –ü—Ä–∏–≤–µ—Ç, –º–∞—Å—Ç–µ—Ä!\n"
            "‚Ä¢ /add_job ‚Äî –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–¥—Ä–∞–±–æ—Ç–∫—É\n"
            "‚Ä¢ /admin ‚Äî –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ –∑–∞—è–≤–∫–∏\n"
            "‚Ä¢ /export ‚Äî –≤—ã–≥—Ä—É–∑–∏—Ç—å –≤ Excel"
        )
    else:
        if not position:
            await message.answer(f"üëã –ü—Ä–∏–≤–µ—Ç, {full_name}!\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏ —Å–≤–æ—é –¥–æ–ª–∂–Ω–æ—Å—Ç—å:", reply_markup=get_positions_keyboard())
            await RegisterPosition.position.set()
        else:
            await message.answer(f"üëã –ü—Ä–∏–≤–µ—Ç, {full_name}!\n‚Ä¢ /find_job ‚Äî –Ω–∞–π—Ç–∏ –ø–æ–¥—Ä–∞–±–æ—Ç–∫—É\n‚Ä¢ /my_bookings ‚Äî –º–æ–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è")

# === –†–ï–ì–ò–°–¢–†–ê–¶–ò–Ø –î–û–õ–ñ–ù–û–°–¢–ò ===
@dp.message_handler(state=RegisterPosition.position)
async def register_position(message: types.Message, state: FSMContext):
    if message.text not in POSITIONS:
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑ —Å–ø–∏—Å–∫–∞!", reply_markup=get_positions_keyboard())
        return
    save_user_position(message.from_user.id, message.text)
    await message.answer(f"‚úÖ –û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å —Ç—ã ‚Äî {message.text}.\n–ú–æ–∂–µ—à—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å /find_job –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ–¥—Ä–∞–±–æ—Ç–æ–∫.")
    await state.finish()

# === –ú–û–ò –ë–†–û–ù–ò–†–û–í–ê–ù–ò–Ø ===
@dp.message_handler(commands=['my_bookings'])
async def my_bookings(message: types.Message):
    user_id = message.from_user.id
    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    cur.execute("SELECT id, position, section, datetime FROM jobs WHERE worker_id = ? AND is_taken = 1", (user_id,))
    bookings = cur.fetchall()
    conn.close()

    if not bookings:
        await message.answer("–£ —Ç–µ–±—è –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π.")
        return

    text = "üìå –¢–≤–æ–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è:\n\n"
    for b in bookings:
        markup = types.InlineKeyboardMarkup()
        btn = types.InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data=f"cancel_{b[0]}")
        markup.add(btn)
        await message.answer(f"ID {b[0]} | {b[1]} | {b[2]} | {b[3]}", reply_markup=markup)

# === –û–¢–ú–ï–ù–ê –ë–†–û–ù–ò ===
@dp.callback_query_handler(lambda c: c.data.startswith('cancel_'))
async def cancel_booking(callback_query: types.CallbackQuery):
    job_id = int(callback_query.data.split('_')[1])
    user_id = callback_query.from_user.id

    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    cur.execute("SELECT worker_id FROM jobs WHERE id = ?", (job_id,))
    row = cur.fetchone()
    if not row or row[0] != user_id:
        await callback_query.answer("–≠—Ç–æ –Ω–µ —Ç–≤–æ—è –±—Ä–æ–Ω—å!", show_alert=True)
        conn.close()
        return

    cur.execute("UPDATE jobs SET is_taken = 0, worker_id = NULL, worker_name = NULL WHERE id = ?", (job_id,))
    conn.commit()
    conn.close()

    await callback_query.message.edit_text("üïó –ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    await callback_query.answer("–ë—Ä–æ–Ω—å –æ—Ç–º–µ–Ω–µ–Ω–∞!")

# === –ê–î–ú–ò–ù–ö–ê –ò –≠–ö–°–ü–û–†–¢ ===
@dp.message_handler(commands=['admin'])
async def admin_panel(message: types.Message):
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return
    cleanup_old_jobs()
    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    cur.execute("SELECT id, position, section, datetime, is_taken, worker_name FROM jobs ORDER BY datetime")
    jobs = cur.fetchall()
    conn.close()
    if not jobs:
        await message.answer("–ù–µ—Ç –ø–æ–¥—Ä–∞–±–æ—Ç–æ–∫.")
        return
    text = "üìã –í—Å–µ –ø–æ–¥—Ä–∞–±–æ—Ç–∫–∏:\n\n"
    for j in jobs:
        status = "‚úÖ –ó–∞–Ω—è—Ç–∞" if j[4] else "üïó –°–≤–æ–±–æ–¥–Ω–∞"
        worker = f" ({j[5]})" if j[5] else ""
        text += f"ID {j[0]} | {j[1]} | {j[2]} | {j[3]} | {status}{worker}\n"
    await message.answer(text)

@dp.message_handler(commands=['export'])
async def export_to_excel(message: types.Message):
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return

    cleanup_old_jobs()
    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    cur.execute("""
        SELECT j.datetime, j.position, j.section, u.full_name, j.worker_id
        FROM jobs j
        LEFT JOIN users u ON j.worker_id = u.user_id
        WHERE j.datetime LIKE ?
        ORDER BY j.datetime
    """, (f"%{datetime.now().strftime('%m.%Y')}%",))
    rows = cur.fetchall()
    conn.close()

    if not rows:
        await message.answer("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∑–∞ —Ç–µ–∫—É—â–∏–π –º–µ—Å—è—Ü.")
        return

    # –°–æ–∑–¥–∞—ë–º Excel
    wb = Workbook()
    ws = wb.active
    ws.title = "–ü–æ–¥—Ä–∞–±–æ—Ç–∫–∏"
    ws.append(["–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è", "–î–æ–ª–∂–Ω–æ—Å—Ç—å", "–£—á–∞—Å—Ç–æ–∫", "–†–∞–±–æ—Ç–Ω–∏–∫", "Telegram ID"])

    for row in rows:
        ws.append(row)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ø–∞–º—è—Ç—å
    output = BytesIO()
    wb.save(output)
    output.seek(0)

    await message.answer_document(
        document=types.InputFile(output, filename=f"podrabotki_{datetime.now().strftime('%m-%Y')}.xlsx"),
        caption="‚úÖ –í—ã–≥—Ä—É–∑–∫–∞ –∑–∞ —Ç–µ–∫—É—â–∏–π –º–µ—Å—è—Ü"
    )

# === –û–°–¢–ê–õ–¨–ù–´–ï –ö–û–ú–ê–ù–î–´ (add_job, find_job –∏ —Ç.–¥.) ===
# ... (–æ—Å—Ç–∞–≤–ª—è–µ–º –≤—Å—ë –∫–∞–∫ –±—ã–ª–æ ‚Äî —è —Å–æ–∫—Ä–∞—Ç–∏–ª –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏, –Ω–æ —Ç—ã –≤—Å—Ç–∞–≤–ª—è–π –ü–û–õ–ù–´–ô –∫–æ–¥ –Ω–∏–∂–µ)

# ‚ö†Ô∏è –í–ê–ñ–ù–û: –í–°–¢–ê–í–¨ –°–Æ–î–ê –û–°–¢–ê–õ–¨–ù–´–ô –ö–û–î –ò–ó –ü–†–ï–î–´–î–£–©–ï–ô –í–ï–†–°–ò–ò:
# - add_job
# - find_job
# - take_job
# (–æ–Ω–∏ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å, –∫—Ä–æ–º–µ –º–µ–ª–æ—á–µ–π)

# –ß—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –ø—É—Ç–∞–Ω–∏—Ü—ã ‚Äî —è –ø—Ä–∏—à–ª—é –ü–û–õ–ù–´–ô –∫–æ–¥ –Ω–∏–∂–µ üëá
